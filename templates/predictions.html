{% extends "base.html" %}

{% block title %}Fishing Predictor Pro - Pr√©visions 10 Jours{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<style>
    body {
        background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        color: #f8fafc;
        min-height: 100vh;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    .container { max-width: 1400px; margin: 0 auto; padding: 0 1rem; }
    .predictions-hero {
        background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
        color: white; padding: 1.25rem 0; text-align: center;
        border-radius: 0 0 16px 16px; margin-bottom: 1.5rem;
    }
    .dashboard-grid {
        display: grid; grid-template-columns: 1fr 2fr; gap: 1.5rem;
    }
    @media (max-width: 1024px) { .dashboard-grid { grid-template-columns: 1fr; } }
    .left-column, .right-column { display: flex; flex-direction: column; gap: 1.25rem; }
    .card {
        background: rgba(30, 41, 59, 0.9);
        backdrop-filter: blur(10px); border-radius: 16px; padding: 1.25rem;
        border: 1px solid #475569; box-shadow: 0 10px 25px rgba(0,0,0,0.3);
    }
    .card-title {
        font-size: 1.2rem; font-weight: 600; margin-bottom: 1rem; color: #e2e8f0;
        display: flex; align-items: center; gap: 0.75rem; padding-bottom: 0.5rem;
        border-bottom: 2px solid #334155;
    }
    .btn {
        padding: 0.6rem 1.2rem; border-radius: 8px; border: none; font-weight: 500;
        cursor: pointer; transition: all 0.3s ease; display: inline-flex; align-items: center;
        gap: 0.5rem; font-size: 0.9rem; min-height: 44px;
    }
    .btn-primary { background: linear-gradient(90deg, #3b82f6, #2563eb); color: white; }
    .btn-secondary { background: rgba(255,255,255,0.1); color: white; border: 1px solid #475569; }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
    .map-container {
        height: 380px; border-radius: 12px; overflow: hidden; position: relative;
        border: 2px solid #475569; box-shadow: 0 10px 25px rgba(0,0,0,0.3);
    }
    #wind-animation-canvas {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 500; display: none;
    }
    .weather-elements-hidden { display: none; }
    .forecast-grid {
        display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 1rem; margin: 1rem 0;
    }
    .forecast-day-card {
        background: rgba(51,65,85,0.6); border-radius: 12px; padding: 1rem;
        text-align: center; transition: all 0.3s; cursor: pointer;
        border: 2px solid transparent; position: relative;
    }
    .forecast-day-card:hover {
        transform: translateY(-3px); border-color: #3b82f6;
        background: rgba(59,130,246,0.1);
    }
    .forecast-day-card.active {
        border-color: #10b981; background: rgba(16,185,129,0.15);
        box-shadow: 0 5px 20px rgba(16,185,129,0.3);
    }
    .day-header {
        font-size: 1rem; font-weight: 600; margin-bottom: 0.25rem; color: #e2e8f0;
        display: flex; align-items: center; justify-content: center; gap: 5px;
    }
    .day-date { font-size: 0.8rem; color: #94a3b8; margin-bottom: 0.5rem; }
    .day-score {
        font-size: 2rem; font-weight: 900; margin: 0.5rem 0;
        background: linear-gradient(90deg, #10b981, #3b82f6);
        -webkit-background-clip: text; background-clip: text; color: transparent;
        line-height: 1;
    }
    .day-decision {
        display: inline-block; padding: 0.3rem 0.8rem; border-radius: 20px;
        font-weight: 600; font-size: 0.8rem; color: white; margin-top: 0.25rem;
    }
    .wind-alert-badge {
        display: inline-block; margin-left: 5px; font-size: 1.1rem;
        cursor: help; filter: drop-shadow(0 0 2px #f59e0b);
    }
    .day-details {
        background: rgba(30,41,59,0.9); border-radius: 16px; padding: 1.5rem;
        margin-top: 1.5rem; border: 1px solid #475569;
    }
    .day-stats-grid {
        display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem; margin: 1rem 0;
    }
    .stat-card {
        background: rgba(51,65,85,0.6); padding: 1rem; border-radius: 12px;
        border-left: 4px solid; text-align: center;
    }
    .stat-value { font-size: 1.3rem; font-weight: 800; color: #f8fafc; margin: 0.25rem 0; }
    .hourly-forecast-grid {
        display: grid; grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
        gap: 0.75rem; margin: 1rem 0;
    }
    .hour-card {
        background: rgba(51,65,85,0.6); padding: 0.75rem; border-radius: 10px;
        text-align: center; border-top: 4px solid; transition: all 0.3s;
    }
    .wind-rose-grid {
        display: flex; flex-wrap: wrap; gap: 0.75rem; justify-content: center; margin: 1rem 0;
    }
    .wind-card {
        background: linear-gradient(145deg, #1e293b, #0f172a);
        border-radius: 50%; width: 90px; height: 90px; padding: 0.5rem;
        box-sizing: border-box; display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        box-shadow: 0 8px 20px rgba(0,0,0,0.6), inset 0 2px 4px rgba(255,255,255,0.05);
        border: 2px solid transparent; transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    .wind-card:hover {
        transform: translateY(-5px) scale(1.05);
        box-shadow: 0 15px 30px rgba(59,130,246,0.3);
    }
    .wind-card .hour {
        font-size: 0.8rem; font-weight: 600; color: #94a3b8; margin-bottom: 0.1rem;
        line-height: 1.2;
    }
    .wind-card .speed {
        font-size: 1rem; font-weight: 800;
        background: linear-gradient(90deg, #3b82f6, #8b5cf6);
        -webkit-background-clip: text; background-clip: text; color: transparent;
        line-height: 1.2; white-space: nowrap;
    }
    .wind-card .direction-icon {
        font-size: 1.3rem; filter: drop-shadow(0 0 5px rgba(59,130,246,0.5));
        margin: 0; line-height: 1;
    }
    .wind-card .direction-name {
        font-size: 0.6rem; font-weight: 600; color: #cbd5e1;
        text-transform: uppercase; letter-spacing: 0.5px; line-height: 1.2;
    }
    .wind-card[data-wind-speed="low"] { border-color: #10b981; }
    .wind-card[data-wind-speed="moderate"] { border-color: #f59e0b; }
    .wind-card[data-wind-speed="high"] { border-color: #ef4444; }
    .wind-card[data-wind-speed="very-high"] { border-color: #8b5cf6; }
    @media (max-width: 480px) {
        .wind-card { width: 70px; height: 70px; padding: 0.3rem; }
        .wind-card .hour { font-size: 0.7rem; }
        .wind-card .speed { font-size: 0.85rem; }
        .wind-card .direction-icon { font-size: 1.1rem; }
        .wind-card .direction-name { font-size: 0.5rem; }
    }
    .hourly-table-modal {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.85); display: none; justify-content: center;
        align-items: center; z-index: 2000; padding: 1rem; animation: fadeIn 0.3s ease;
    }
    .hourly-table-content {
        background: rgba(30,41,59,0.95); backdrop-filter: blur(10px);
        border-radius: 15px; width: 95%; max-width: 1400px; max-height: 85vh;
        overflow: auto; position: relative; box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        border: 1px solid #475569;
    }
    .score-excellent { background: #10b981; }
    .score-good { background: #3b82f6; }
    .score-medium { background: #f59e0b; }
    .score-poor { background: #ef4444; }
    .score-very-poor { background: #6b7280; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @media (max-width: 768px) {
        .predictions-hero h1 { font-size: 1.5rem; }
        .map-container { height: 350px; }
        .forecast-grid { grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); }
        .day-stats-grid { grid-template-columns: 1fr 1fr; }
        .btn { width: 100%; }
    }
    @media (max-width: 480px) {
        .predictions-hero h1 { font-size: 1.3rem; }
        .map-container { height: 300px; }
        .forecast-grid { grid-template-columns: repeat(2, 1fr); }
        .day-stats-grid { grid-template-columns: 1fr; }
    }
    .lunar-card {
        background: rgba(15,23,42,0.95); border: 1px solid #8b5cf6;
        box-shadow: 0 0 20px rgba(139,92,246,0.2);
    }
    .lunar-badge {
        background: #8b5cf6; color: white; font-size: 0.75rem;
        padding: 0.2rem 0.6rem; border-radius: 30px; margin-left: 0.75rem;
    }
    .moon-wheel {
        display: grid; grid-template-columns: repeat(5, 1fr); gap: 0.75rem;
        padding: 0.5rem; position: relative;
    }
    .moon-day {
        background: rgba(30,41,59,0.8); border-radius: 50% 50% 30% 30%;
        padding: 1rem 0.5rem; text-align: center; border: 2px solid;
        transition: all 0.3s cubic-bezier(0.25,0.46,0.45,0.94);
        cursor: pointer;
    }
    .moon-day:hover {
        transform: scale(1.1) rotate(5deg); z-index: 10;
        box-shadow: 0 0 15px currentColor;
    }
    .moon-icon {
        font-size: 2.2rem; line-height: 1; margin-bottom: 0.25rem;
        filter: drop-shadow(0 0 5px rgba(139,92,246,0.5));
    }
    .moon-phase-name {
        font-size: 0.7rem; font-weight: 600; color: #cbd5e1;
        text-transform: uppercase; letter-spacing: 0.5px;
    }
    .moon-score {
        font-size: 1.2rem; font-weight: 900; margin: 0.25rem 0;
        background: linear-gradient(90deg, #f8fafc, #e2e8f0);
        -webkit-background-clip: text; background-clip: text; color: transparent;
    }
    .moon-day small { font-size: 0.65rem; color: #94a3b8; display: block; }
    .lunar-legend {
        display: flex; justify-content: space-around; margin-top: 1rem;
        padding-top: 0.75rem; border-top: 1px solid #334155;
        font-size: 0.75rem; color: #94a3b8;
    }
    .legend-dot {
        display: inline-block; width: 10px; height: 10px;
        border-radius: 50%; margin-right: 0.25rem;
    }
    @keyframes moonPulse {
        0% { transform: scale(1); }
        100% { transform: scale(1.05); }
    }
    .moon-day.active-moon {
        border-color: #8b5cf6; background: rgba(139,92,246,0.15);
        animation: moonPulse 1.5s infinite alternate;
    }
    .notification {
        position: fixed; top: 20px; right: 20px; padding: 15px 20px;
        border-radius: 8px; color: white; font-weight: 500;
        z-index: 9999; animation: slideIn 0.3s ease; max-width: 350px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }
    .notification.success { background: linear-gradient(135deg, #10b981, #059669); }
    .notification.error { background: linear-gradient(135deg, #ef4444, #dc2626); }
    .notification.info { background: linear-gradient(135deg, #3b82f6, #2563eb); }
    @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
    }
    .confidence-badge {
        font-size: 0.7rem; color: #94a3b8; margin-top: 0.25rem;
    }
    .simulation-note {
        font-size: 0.7rem; color: #f59e0b; margin-top: 0.25rem;
        font-style: italic;
    }
</style>
{% endblock %}

{% block content %}
<div class="predictions-hero">
    <div class="container">
        <h1><i class="fas fa-calendar-alt"></i> Pr√©visions 10 Jours</h1>
        <p>Donn√©es temps r√©el ‚Ä¢ Vent synchronis√© ‚Ä¢ Fiabilit√© indiqu√©e</p>
    </div>
</div>

<div class="container">
    <div class="weather-elements-hidden">
        <div id="temperature"></div><div id="weather-condition"></div><div id="wind-speed"></div>
        <div id="weather-location-name"></div><div id="weather-icon"></div><div id="wind-direction"></div>
        <div id="weather-pressure"></div><div id="wind-impact"></div><div id="wind-fishing-tips"></div>
        <div id="weather-updated"></div>
    </div>

    <div class="dashboard-grid">
        <div class="left-column">
            <div class="card">
                <div class="card-title">
                    <i class="fas fa-map"></i> Carte des Spots
                    <button class="btn btn-secondary" style="margin-left:auto;padding:0.4rem 0.8rem" onclick="window.useCurrentLocation()">
                        <i class="fas fa-location-dot"></i>
                    </button>
                </div>
                <div class="map-container" id="map-container"></div>
                <div style="display:flex;gap:0.5rem;margin-top:0.75rem;flex-wrap:wrap">
                    <button class="btn btn-secondary" onclick="window.loadForecast()"><i class="fas fa-sync-alt"></i> Actualiser</button>
                    <button class="btn btn-secondary" onclick="window.toggleWindLayer()" id="windToggleBtn"><i class="fas fa-wind"></i> Vent</button>
                    <button class="btn btn-primary" onclick="window.showHourlyForecastTable()" style="margin-left:auto"><i class="fas fa-table"></i> Tableau</button>
                </div>
            </div>
            
            <div class="card">
                <div class="card-title"><i class="fas fa-sliders-h"></i> Param√®tres</div>
                <div style="margin-bottom:0.75rem">
                    <label style="display:block;margin-bottom:0.4rem;color:#cbd5e1;font-size:0.9rem"><i class="fas fa-fish"></i> Esp√®ce</label>
                    <div class="species-selector-mini" id="species-selector"></div>
                </div>
                <div id="spot-info" style="margin-top:1rem;padding:0.75rem;background:rgba(51,65,85,0.6);border-radius:8px;display:none"></div>
            </div>
            
            <div class="card lunar-card">
                <div class="card-title"><i class="fas fa-moon"></i> Calendrier Lunaire <span class="lunar-badge">üåì Solunar</span></div>
                <div class="moon-wheel" id="moonWheel"></div>
                <div class="lunar-legend">
                    <span><span class="legend-dot" style="background:#10b981;"></span> Excellent</span>
                    <span><span class="legend-dot" style="background:#3b82f6;"></span> Bon</span>
                    <span><span class="legend-dot" style="background:#f59e0b;"></span> Moyen</span>
                    <span><span class="legend-dot" style="background:#ef4444;"></span> Faible</span>
                </div>
            </div>
            
            <div class="card">
                <div class="card-title"><i class="fas fa-bell"></i> Alertes</div>
                <div id="alerts-container">
                    <div class="alert-banner" id="best-day-alert" style="display:none;background:linear-gradient(90deg,#f59e0b,#d97706);color:white;padding:0.75rem;border-radius:8px;margin-bottom:0.75rem">
                        <i class="fas fa-crown"></i> <span id="best-day-text">Meilleur jour: --</span>
                    </div>
                    <div id="alerts-list"></div>
                </div>
            </div>
        </div>
        
        <div class="right-column">
            <div class="card">
                <div class="card-title"><i class="fas fa-chart-line"></i> Tendance 10 Jours</div>
                <div class="trend-chart-container" style="height:200px;margin:0.5rem 0">
                    <canvas id="trend-chart"></canvas>
                </div>
            </div>
            
            <div class="card">
                <div class="card-title"><i class="fas fa-calendar-week"></i> Pr√©visions 10 Jours</div>
                
                <div id="forecast-loading" style="display:none;text-align:center;padding:1rem">
                    <div class="loading-spinner" style="width:30px;height:30px;border:3px solid rgba(255,255,255,0.1);border-top-color:#3b82f6;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 0.5rem"></div>
                    <p style="color:#94a3b8">Chargement...</p>
                </div>
                
                <div id="forecast-container" style="display:none">
                    <div class="forecast-grid" id="forecast-grid"></div>
                    
                    <div id="day-details" class="day-details" style="display:none">
                        <h3 id="selected-day-title" style="color:#3b82f6;margin-bottom:0.75rem;font-size:1.1rem"></h3>
                        
                        <div class="day-stats-grid">
                            <div class="stat-card" style="border-left-color:#10b981">
                                <h4 style="margin:0 0 0.25rem;color:#cbd5e1;font-size:0.85rem">Score</h4>
                                <div class="stat-value" id="detail-score">--%</div>
                            </div>
                            <div class="stat-card" style="border-left-color:#3b82f6">
                                <h4 style="margin:0 0 0.25rem;color:#cbd5e1;font-size:0.85rem">Vent</h4>
                                <div class="stat-value" id="detail-wind">-- km/h</div>
                                <div style="font-size:0.8rem;color:#94a3b8" id="detail-wind-dir"></div>
                            </div>
                            <div class="stat-card" style="border-left-color:#f59e0b">
                                <h4 style="margin:0 0 0.25rem;color:#cbd5e1;font-size:0.85rem">Temp.</h4>
                                <div class="stat-value" id="detail-temp">--¬∞C</div>
                            </div>
                            <div class="stat-card" style="border-left-color:#8b5cf6">
                                <h4 style="margin:0 0 0.25rem;color:#cbd5e1;font-size:0.85rem">Vagues</h4>
                                <div class="stat-value" id="detail-waves">-- m</div>
                            </div>
                        </div>
                        
                        <h4 style="color:#e2e8f0;margin:1rem 0 0.5rem;font-size:0.95rem">
                            <i class="fas fa-clock"></i> Meilleures plages horaires
                        </h4>
                        <div class="hourly-forecast-grid" id="hourly-forecast-grid"></div>

                        <h4 style="color:#e2e8f0;margin:1.5rem 0 0.75rem;font-size:0.95rem">
                            <i class="fas fa-wind"></i> Vent d√©taill√© (toutes les 3h)
                        </h4>
                        <div class="wind-rose-grid" id="hourlyWindGrid"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="hourly-table-modal" id="hourlyTableModal">
    <div class="hourly-table-content">
        <div style="padding:1rem;background:linear-gradient(135deg,#1e3a8a,#3b82f6);color:white;border-radius:15px 15px 0 0;display:flex;justify-content:space-between;align-items:center">
            <h3 id="hourly-table-title" style="margin:0;font-size:1.2rem"><i class="fas fa-table"></i> Pr√©visions Horaires</h3>
            <button class="close-modal" id="closeHourlyTable" style="background:rgba(255,255,255,.2);border:none;color:white;font-size:1.5rem;cursor:pointer;width:36px;height:36px;border-radius:50%">&times;</button>
        </div>
        <div id="hourly-table-container" style="padding:1rem;max-height:70vh;overflow:auto"></div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// ============================================
// FISHING PREDICTOR PRO - PR√âVISIONS 10 JOURS
// Version scientifique corrig√©e - Mars 2026
// ============================================

const AppState = {
    currentLat: 36.8065, 
    currentLon: 10.1815, 
    currentSpot: null, 
    currentSpecies: 'loup',
    forecastData: null, 
    selectedDay: 0,
    map: null, 
    markers: [], 
    trendChart: null,
    windEnabled: false, 
    windCanvas: null, 
    windCtx: null, 
    windParticles: [],
    windAnimationId: null, 
    windDirection: 90, 
    windSpeed: 10, 
    initialized: false
};

const Config = {
    spots: [
        { name: 'Tunis Marina', lat: 36.8065, lon: 10.1815, type: 'port', depth: '8-12m' },
        { name: 'Cap Bon', lat: 36.8475, lon: 11.0940, type: 'rocheux', depth: '15-25m' },
        { name: 'Bizerte', lat: 37.2747, lon: 9.8739, type: 'port', depth: '10-18m' },
        { name: 'Sousse', lat: 35.8254, lon: 10.6360, type: 'port', depth: '6-10m' },
        { name: 'Hammamet', lat: 36.4000, lon: 10.6000, type: 'plage', depth: '5-8m' }
    ],
    species: {
        loup: { name: 'Loup de Mer', icon: 'üêü', color: '#3b82f6' },
        daurade: { name: 'Daurade Royale', icon: 'üê†', color: '#10b981' },
        thon: { name: 'Thon Rouge', icon: 'ü¶à', color: '#ef4444' }
    },
    // Seuils de vent par esp√®ce (km/h)
    windThresholds: {
        loup: 30,
        daurade: 25,
        thon: 40,
        pageot: 30,
        sar: 30,
        mulet: 35,
        marbr√©: 25,
        rouget: 30,
        s√©riole: 35,
        bonite: 40,
        default: 30
    }
};

// ============================================
// FONCTIONS UTILITAIRES CORRIG√âES
// ============================================

/**
 * Calcule la distance entre deux points GPS (formule de Haversine)
 */
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
              Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

/**
 * Affiche une notification temporaire
 */
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.style.animation = 'slideIn 0.3s reverse';
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

/**
 * Convertit les degr√©s en nom de direction du vent (provenance)
 */
function getWindDirectionName(deg) {
    const directions = ['Nord', 'Nord-Est', 'Est', 'Sud-Est', 'Sud', 'Sud-Ouest', 'Ouest', 'Nord-Ouest'];
    deg = parseFloat(deg) || 0;
    deg = ((deg % 360) + 360) % 360;
    const index = Math.round(deg / 45) % 8;
    return directions[index];
}

/**
 * Convertit les degr√©s en abr√©viation de direction (provenance)
 */
function getWindDirectionAbbr(deg) {
    const abbreviations = ['N', 'NE', 'E', 'SE', 'S', 'SO', 'O', 'NO'];
    deg = parseFloat(deg) || 0;
    deg = ((deg % 360) + 360) % 360;
    const index = Math.round(deg / 45) % 8;
    return abbreviations[index];
}

/**
 * Convertit les degr√©s en ic√¥ne de direction (provenance)
 * Convention m√©t√©o : la fl√®che pointe vers la direction d'o√π vient le vent
 */
function getWindDirectionIcon(deg) {
    // Tableau des ic√¥nes dans l'ordre : [N, NE, E, SE, S, SO, O, NO]
    const icons = ['‚¨áÔ∏è', '‚ÜôÔ∏è', '‚¨ÖÔ∏è', '‚ÜñÔ∏è', '‚¨ÜÔ∏è', '‚ÜóÔ∏è', '‚û°Ô∏è', '‚ÜòÔ∏è'];
    
    // S'assurer que deg est un nombre valide entre 0 et 360
    deg = parseFloat(deg) || 0;
    deg = ((deg % 360) + 360) % 360;
    
    // Calculer l'index (0-7)
    const index = Math.round(deg / 45) % 8;
    
    // Log de d√©bogage (√† supprimer en production)
    console.log(`getWindDirectionIcon: ${deg}¬∞ ‚Üí ${icons[index]} (${getWindDirectionName(deg)})`);
    
    return icons[index];
}

/**
 * Calcule la cat√©gorie de vitesse du vent
 */
function getWindSpeedCategory(speed) {
    if (speed < 10) return 'low';
    if (speed < 20) return 'moderate';
    if (speed < 30) return 'high';
    return 'very-high';
}

/**
 * Calcule la hauteur estim√©e des vagues en fonction de la vitesse du vent
 */
function estimateWaveHeight(windSpeed) {
    if (windSpeed < 10) return 0.2;
    if (windSpeed < 20) return 0.2 + (windSpeed - 10) * 0.04;
    if (windSpeed < 30) return 0.6 + (windSpeed - 20) * 0.06;
    if (windSpeed < 40) return 1.2 + (windSpeed - 30) * 0.08;
    if (windSpeed < 50) return 2.0 + (windSpeed - 40) * 0.10;
    if (windSpeed < 60) return 3.0 + (windSpeed - 50) * 0.12;
    return 4.2 + (windSpeed - 60) * 0.15;
}

// ============================================
// GESTION DE L'ANIMATION DU VENT
// ============================================

const WindAnimation = {
    init() {
        if (!AppState.map) return;
        const container = document.getElementById('map-container');
        if (!container) return;
        const oldCanvas = document.getElementById('wind-animation-canvas');
        if (oldCanvas) oldCanvas.remove();
        const canvas = document.createElement('canvas');
        canvas.id = 'wind-animation-canvas';
        container.appendChild(canvas);
        AppState.windCanvas = canvas;
        AppState.windCtx = canvas.getContext('2d');
        const resize = () => {
            if (container && canvas) {
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                this._initParticles();
            }
        };
        resize();
        window.addEventListener('resize', resize);
    },
    
    _initParticles() {
        const canvas = AppState.windCanvas;
        if (!canvas) return;
        const count = Math.min(120, Math.floor(canvas.width * canvas.height / 2000));
        AppState.windParticles = [];
        for (let i = 0; i < count; i++) {
            AppState.windParticles.push({
                x: Math.random() * canvas.width, 
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 1,
                speed: (Math.random() * 1.5 + 0.5) * (AppState.windSpeed / 12 || 1),
                opacity: Math.random() * 0.5 + 0.2
            });
        }
    },
    
    _animate() {
        if (!AppState.windEnabled || !AppState.windCtx || !AppState.windCanvas) return;
        const ctx = AppState.windCtx;
        const canvas = AppState.windCanvas;
        if (AppState.forecastData && AppState.forecastData[AppState.selectedDay]) {
            const day = AppState.forecastData[AppState.selectedDay];
            AppState.windDirection = day.wind?.direction || 90;
            AppState.windSpeed = day.wind?.speed || 10;
        }
        const windAngle = ((AppState.windDirection + 90) % 360) * Math.PI / 180;
        const speedFactor = Math.max(0.5, Math.min(2, AppState.windSpeed / 10));
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.globalCompositeOperation = 'source-over';
        AppState.windParticles.forEach(p => {
            p.x += Math.cos(windAngle) * p.speed * speedFactor;
            p.y += Math.sin(windAngle) * p.speed * speedFactor;
            if (p.x > canvas.width) p.x = 0;
            if (p.x < 0) p.x = canvas.width;
            if (p.y > canvas.height) p.y = 0;
            if (p.y < 0) p.y = canvas.height;
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(windAngle);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-6, -2);
            ctx.lineTo(-6, 2);
            ctx.closePath();
            ctx.fillStyle = `rgba(59, 130, 246, ${p.opacity * 0.7})`;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, 0, p.size, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(59, 130, 246, ${p.opacity})`;
            ctx.fill();
            ctx.restore();
        });
        AppState.windAnimationId = requestAnimationFrame(() => this._animate());
    },
    
    _updateButton(isActive) {
        const btn = document.getElementById('windToggleBtn');
        if (btn) {
            if (isActive) {
                btn.innerHTML = '<i class="fas fa-wind"></i> Masquer vent';
                btn.classList.add('btn-primary');
                btn.classList.remove('btn-secondary');
            } else {
                btn.innerHTML = '<i class="fas fa-wind"></i> Afficher vent';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            }
        }
    },
    
    toggleLayer() {
        if (AppState.windEnabled) this.removeAnimation();
        else this.addAnimation();
    },
    
    addAnimation() {
        AppState.windEnabled = true;
        if (AppState.windCanvas) {
            AppState.windCanvas.style.display = 'block';
            this._initParticles();
            this._animate();
        }
        this._updateButton(true);
    },
    
    removeAnimation() {
        AppState.windEnabled = false;
        if (AppState.windCanvas) AppState.windCanvas.style.display = 'none';
        if (AppState.windAnimationId) {
            cancelAnimationFrame(AppState.windAnimationId);
            AppState.windAnimationId = null;
        }
        this._updateButton(false);
    },
    
    updateAnimation(direction, speed) {
        if (direction !== undefined) AppState.windDirection = direction;
        if (speed !== undefined) AppState.windSpeed = speed;
        if (AppState.windEnabled) this._initParticles();
    },
    
    syncWithForecast() {
        if (AppState.forecastData && AppState.forecastData[AppState.selectedDay]) {
            const day = AppState.forecastData[AppState.selectedDay];
            this.updateAnimation(day.wind?.direction, day.wind?.speed);
        }
    }
};

// ============================================
// GESTION DE LA CARTE
// ============================================

const MapManager = {
    init() {
        try {
            AppState.map = L.map('map-container').setView([AppState.currentLat, AppState.currentLon], 10);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap' }).addTo(AppState.map);
            this._addSpots();
            AppState.map.on('click', (e) => {
                SpotSelector.select({
                    name: `Position (${e.latlng.lat.toFixed(4)}, ${e.latlng.lng.toFixed(4)})`,
                    lat: e.latlng.lat, lon: e.latlng.lng, type: 'custom', depth: '?'
                });
            });
            WindAnimation.init();
            console.log('‚úÖ Carte initialis√©e');
        } catch (e) { 
            console.error('‚ùå Erreur carte:', e);
            showNotification('Erreur lors de l\'initialisation de la carte', 'error');
        }
    },
    
    _addSpots() {
        Config.spots.forEach(spot => {
            const color = spot.type === 'port' ? '#3b82f6' : spot.type === 'plage' ? '#10b981' : '#f59e0b';
            const icon = L.divIcon({ html: `<div style="background:${color};width:12px;height:12px;border-radius:50%;border:2px solid white;box-shadow:0 0 5px rgba(0,0,0,0.5);"></div>`, iconSize: [16,16] });
            const marker = L.marker([spot.lat, spot.lon], { icon }).addTo(AppState.map);
            marker.bindPopup(`
                <div style="min-width:200px;">
                    <h3 style="margin:0 0 5px;color:#1e40af">${spot.name}</h3>
                    <span style="background:${color};color:white;padding:2px 8px;border-radius:12px;font-size:12px">${spot.type}</span>
                    <p style="margin:5px 0">Profondeur: ${spot.depth}</p>
                    <button onclick="window.selectSpot(${spot.lat}, ${spot.lon}, '${spot.name}')" 
                            style="margin-top:10px;padding:8px;background:#3b82f6;color:white;border:none;border-radius:4px;width:100%;">
                        <i class="fas fa-check"></i> S√©lectionner
                    </button>
                </div>
            `);
            marker.on('click', () => { window.selectSpot(spot.lat, spot.lon, spot.name); });
            AppState.markers.push(marker);
        });
    }
};

// ============================================
// S√âLECTION DES SPOTS
// ============================================

const SpotSelector = {
    select(param1, param2, param3) {
        if (typeof param1 === 'object') {
            this._selectSpot(param1.lat, param1.lon, param1.name);
        } else {
            this._selectSpot(param1, param2, param3);
        }
    },
    
    _selectSpot(lat, lon, name) {
        const spot = { lat, lon, name, type: 'custom', depth: '?' };
        AppState.currentSpot = spot;
        AppState.currentLat = lat;
        AppState.currentLon = lon;
        localStorage.setItem('currentLat', lat);
        localStorage.setItem('currentLon', lon);
        localStorage.setItem('currentSpotName', name);
        
        this._updateUI(spot);
        if (AppState.map) AppState.map.setView([lat, lon], 13);
        ForecastLoader.load();
        showNotification(`Spot s√©lectionn√© : ${name}`, 'success');
    },
    
    _updateUI(spot) {
        const spotInfo = document.getElementById('spot-info');
        if (spotInfo) {
            let distanceHtml = '';
            const distance = calculateDistance(AppState.currentLat, AppState.currentLon, spot.lat, spot.lon);
            distanceHtml = `<div style="background:#1e293b;padding:0.5rem 1rem;border-radius:20px;text-align:center">
                <div style="color:#94a3b8;font-size:.8rem">Distance</div>
                <div style="font-weight:700;font-size:1.3rem;color:#f8fafc">${distance.toFixed(1)} km</div>
            </div>`;
            
            spotInfo.style.display = 'block';
            spotInfo.innerHTML = `
                <div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;">
                    <div>
                        <h3 style="margin:0;color:#3b82f6">${this.escapeHTML(spot.name)}</h3>
                        <div style="color:#94a3b8;font-size:.9rem;margin-top:.25rem">${spot.lat.toFixed(4)}, ${spot.lon.toFixed(4)}</div>
                    </div>
                    ${distanceHtml}
                </div>`;
        }
    },
    
    escapeHTML(str) { 
        return String(str).replace(/[&<>"]/g, c => ({ '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;' })[c] || c); 
    },
    
    useCurrentLocation() {
        if (!navigator.geolocation) { 
            alert('G√©olocalisation non support√©e'); 
            return; 
        }
        navigator.geolocation.getCurrentPosition(
            pos => { 
                this._selectSpot(pos.coords.latitude, pos.coords.longitude, 'Ma position'); 
            },
            () => { 
                alert('Impossible d\'obtenir la position');
                showNotification('Impossible d\'obtenir votre position', 'error');
            }
        );
    }
};

// ============================================
// CHARGEMENT DES PR√âVISIONS
// ============================================

const ForecastLoader = {
    async load() {
        if (!AppState.currentSpot) return;
        document.getElementById('forecast-loading').style.display = 'block';
        document.getElementById('forecast-container').style.display = 'none';
        try {
            const url = `/api/forecast_10days?lat=${AppState.currentLat}&lon=${AppState.currentLon}&species=${AppState.currentSpecies}`;
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.status === 'success' && Array.isArray(data.forecast)) {
                const forecast = data.forecast.map((day) => {
                    let hourlyWind = day.hourly_wind || [];
                    
                    // S'assurer que les donn√©es horaires ont les bons champs
                    hourlyWind = hourlyWind.map(w => ({
                        time: w.time,
                        speed_kmh: w.speed_kmh,
                        direction_deg: w.direction_deg,
                        direction_name: w.direction_name || getWindDirectionName(w.direction_deg),
                        direction_abbr: w.direction_abbr || getWindDirectionAbbr(w.direction_deg),
                        direction_icon: getWindDirectionIcon(w.direction_deg) // Recalculer pour √™tre s√ªr
                    }));
                    
                    const waveHeight = day.weather?.wave_height || 
                                      estimateWaveHeight(day.weather?.wind_speed || 0);
                    
                    return {
                        date: day.date, 
                        score: day.score,
                        confidence: day.confidence || (day.day === 1 ? 0.95 : day.day === 2 ? 0.9 : day.day === 3 ? 0.85 : 0.5),
                        note: day.note || null,
                        wind: { 
                            speed: day.weather?.wind_speed || 10, 
                            direction: day.weather?.wind_direction_deg || 0, 
                            direction_name: day.weather?.wind_direction || getWindDirectionName(day.weather?.wind_direction_deg || 0)
                        },
                        temperature: day.weather?.temp_avg || day.weather?.temperature || 20,
                        wave_height: waveHeight, 
                        hourlyWind: hourlyWind, 
                        source: day.data_source || 'real_forecast'
                    };
                });
                AppState.forecastData = forecast;
                document.getElementById('forecast-loading').style.display = 'none';
                document.getElementById('forecast-container').style.display = 'block';
                ForecastDisplay.render();
                TrendChart.update();
                Alerts.update();
                this._renderLunarCalendar();
                console.log('‚úÖ Pr√©visions charg√©es:', data.source || 'API');
            } else {
                console.warn('‚ö†Ô∏è Format de donn√©es invalide, utilisation du fallback');
                await this._loadFallbackForecast();
            }
        } catch (error) {
            console.error('‚ùå Erreur chargement pr√©visions:', error);
            showNotification('Erreur de chargement des pr√©visions', 'error');
            await this._loadFallbackForecast();
        }
    },
    
    async _loadFallbackForecast() {
        await new Promise(resolve => setTimeout(resolve, 500));
        const today = new Date();
        const seed = Math.abs(Math.sin(AppState.currentLat * 1000 + AppState.currentLon * 1000));
        const forecast = [];
        
        for (let i = 0; i < 10; i++) {
            const date = new Date(today);
            date.setDate(today.getDate() + i);
            const random = Math.abs(Math.sin(seed + i * 1000));
            // Suppression du biais week-end
            let score = 50 + Math.sin(i * 0.5) * 15;
            score = Math.max(20, Math.min(95, Math.round(score)));
            const windSpeed = 8 + Math.round(random * 15);
            const windDirection = Math.round(random * 360);
            const temperature = 18 + Math.round(random * 10);
            const waveHeight = estimateWaveHeight(windSpeed);
            
            // Fiabilit√© d√©croissante
            let confidence = 0.95;
            if (i === 1) confidence = 0.9;
            else if (i === 2) confidence = 0.85;
            else if (i === 3) confidence = 0.75;
            else if (i === 4) confidence = 0.65;
            else if (i === 5) confidence = 0.55;
            else if (i === 6) confidence = 0.5;
            else if (i === 7) confidence = 0.45;
            else if (i === 8) confidence = 0.4;
            else if (i === 9) confidence = 0.35;
            
            let note = null;
            if (i >= 5) note = "Donn√©es simul√©es ‚Äì tendance uniquement";
            
            const hours = [0,3,6,9,12,15,18,21];
            const hourlyWind = hours.map(h => {
                const speedVariation = 0.8 + 0.4 * Math.sin(h * Math.PI / 12);
                let speed = Math.round(windSpeed * speedVariation * 10) / 10;
                let dirVariation = 15 * Math.sin(h / 3);
                let direction = (windDirection + dirVariation + 360) % 360;
                
                return {
                    time: `${h.toString().padStart(2,'0')}h`,
                    speed_kmh: speed,
                    direction_deg: direction,
                    direction_name: getWindDirectionName(direction),
                    direction_abbr: getWindDirectionAbbr(direction),
                    direction_icon: getWindDirectionIcon(direction)
                };
            });
            
            forecast.push({
                date: date.toISOString().split('T')[0], 
                score: score,
                confidence: confidence,
                note: note,
                wind: { 
                    speed: windSpeed, 
                    direction: windDirection, 
                    direction_name: getWindDirectionName(windDirection) 
                },
                temperature: temperature, 
                wave_height: waveHeight, 
                hourlyWind: hourlyWind,
                source: 'fallback'
            });
        }
        
        AppState.forecastData = forecast;
        document.getElementById('forecast-loading').style.display = 'none';
        document.getElementById('forecast-container').style.display = 'block';
        ForecastDisplay.render();
        TrendChart.update();
        Alerts.update();
        this._renderLunarCalendar();
        showNotification('Utilisation des donn√©es de simulation', 'info');
    },
    
    _renderLunarCalendar() {
        if (!AppState.forecastData) return;
        const wheel = document.getElementById('moonWheel');
        if (!wheel) return;
        
        const Lunar = {
            icons: { 
                'Nouvelle Lune':'üåë',
                'Premier Croissant':'üåí',
                'Premier Quartier':'üåì',
                'Lune Gibbeuse Croissante':'üåî',
                'Pleine Lune':'üåï',
                'Lune Gibbeuse D√©croissante':'üåñ',
                'Dernier Quartier':'üåó',
                'Dernier Croissant':'üåò' 
            },
            getPhase(date) {
                const knownNewMoon = new Date('2024-01-11T00:00:00Z');
                const daysSince = (date - knownNewMoon) / (1000*60*60*24);
                const lunations = daysSince / 29.530588853;
                const phaseIndex = lunations - Math.floor(lunations);
                if (phaseIndex < 0.03) return 'Nouvelle Lune';
                if (phaseIndex < 0.19) return 'Premier Croissant';
                if (phaseIndex < 0.28) return 'Premier Quartier';
                if (phaseIndex < 0.47) return 'Lune Gibbeuse Croissante';
                if (phaseIndex < 0.53) return 'Pleine Lune';
                if (phaseIndex < 0.72) return 'Lune Gibbeuse D√©croissante';
                if (phaseIndex < 0.81) return 'Dernier Quartier';
                if (phaseIndex < 0.97) return 'Dernier Croissant';
                return 'Nouvelle Lune';
            },
            getFishingScore(phase) {
                const scores = { 
                    'Nouvelle Lune':95,
                    'Premier Croissant':80,
                    'Premier Quartier':60,
                    'Lune Gibbeuse Croissante':75,
                    'Pleine Lune':85,
                    'Lune Gibbeuse D√©croissante':70,
                    'Dernier Quartier':55,
                    'Dernier Croissant':65 
                };
                return scores[phase] || 50;
            }
        };
        
        let html = '';
        AppState.forecastData.forEach((day, index) => {
            const date = new Date(day.date);
            const phase = Lunar.getPhase(date);
            const icon = Lunar.icons[phase];
            let baseScore = Lunar.getFishingScore(phase);
            const weatherScore = day.score || 50;
            let borderColor = '#ef4444';
            if (weatherScore >= 80) borderColor = '#10b981';
            else if (weatherScore >= 60) borderColor = '#3b82f6';
            else if (weatherScore >= 40) borderColor = '#f59e0b';
            const isActive = (index === AppState.selectedDay) ? 'active-moon' : '';
            
            html += `<div class="moon-day ${isActive}" style="border-color: ${borderColor};" onclick="window.selectDay(${index})">
                <div class="moon-icon">${icon}</div>
                <div class="moon-phase-name">${phase}</div>
                <div style="display:flex; justify-content:center; gap:0.5rem; margin:0.25rem 0;">
                    <span style="background:#3b82f6; color:white; padding:0.2rem 0.4rem; border-radius:12px; font-size:0.7rem;">üå°Ô∏è ${weatherScore}%</span>
                    <span style="background:#8b5cf6; color:white; padding:0.2rem 0.4rem; border-radius:12px; font-size:0.7rem;">üåô ${baseScore}%</span>
                </div>
                <small>${date.toLocaleDateString('fr-FR', { weekday: 'short' })}</small>
            </div>`;
        });
        wheel.innerHTML = html;
    }
};

// ============================================
// AFFICHAGE DES PR√âVISIONS
// ============================================

const ForecastDisplay = {
    render() {
        if (!AppState.forecastData) return;
        let html = '';
        AppState.forecastData.forEach((day, i) => {
            const date = new Date(day.date);
            const dayName = date.toLocaleDateString('fr-FR', { weekday: 'short' });
            const dayNum = date.getDate();
            const month = date.toLocaleDateString('fr-FR', { month: 'short' });
            const score = day.score;
            let color = score >= 80 ? '#10b981' : score >= 60 ? '#3b82f6' : score >= 40 ? '#f59e0b' : '#ef4444';
            let decision = score >= 80 ? 'Excellent' : score >= 60 ? 'Bon' : score >= 40 ? 'Moyen' : 'Faible';
            let windAlertBadge = '';
            
            // Seuil de vent esp√®ce-d√©pendant
            const threshold = Config.windThresholds[AppState.currentSpecies] || Config.windThresholds.default;
            if (i < 3 && day.wind.speed > threshold) {
                windAlertBadge = `<span class="wind-alert-badge" title="Vent fort pr√©vu : ${day.wind.speed} km/h (seuil ${threshold} km/h pour cette esp√®ce)">‚ö†Ô∏è</span>`;
            }
            
            // Badge de confiance
            let confidenceText = '';
            if (day.confidence) {
                let confColor = day.confidence > 0.8 ? '#10b981' : day.confidence > 0.6 ? '#f59e0b' : '#94a3b8';
                confidenceText = `<div class="confidence-badge" style="color:${confColor}">Fiabilit√© ${Math.round(day.confidence*100)}%</div>`;
            }
            
            // Note de simulation
            let noteText = '';
            if (day.note) {
                noteText = `<div class="simulation-note">${day.note}</div>`;
            }
            
            html += `<div class="forecast-day-card ${i === 0 ? 'active' : ''}" onclick="window.selectDay(${i})">
                <div class="day-header">${dayName} ${windAlertBadge}</div>
                <div class="day-date">${dayNum} ${month}</div>
                <div class="day-score">${score}%</div>
                <div class="day-decision" style="background:${color}">${decision}</div>
                ${confidenceText}
                ${noteText}
            </div>`;
        });
        document.getElementById('forecast-grid').innerHTML = html;
        this.selectDay(0);
    },
    
    selectDay(index) {
        AppState.selectedDay = index;
        const day = AppState.forecastData[index];
        if (!day) return;
        
        WindAnimation.syncWithForecast();
        const date = new Date(day.date);
        document.getElementById('selected-day-title').textContent = date.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });
        document.getElementById('detail-score').textContent = `${day.score}%`;
        document.getElementById('detail-wind').textContent = `${day.wind.speed} km/h`;
        document.getElementById('detail-wind-dir').textContent = day.wind.direction_name;
        document.getElementById('detail-temp').textContent = `${day.temperature}¬∞C`;
        document.getElementById('detail-waves').textContent = `${day.wave_height} m`;
        
// Affichage des plages horaires selon les donn√©es disponibles
let hoursHtml = '';
if (index <= 2) {
    // Extraire les heures depuis les donn√©es horaires de vent
    const hourlyData = day.hourlyWind || [];
    
    // D√©finir les p√©riodes
    const periods = [
        { name: 'Matin', start: 5, end: 9, emoji: 'üåÖ' },
        { name: 'Mi-journ√©e', start: 12, end: 14, emoji: '‚òÄÔ∏è' },
        { name: 'Soir', start: 16, end: 19, emoji: 'üåÜ' }
    ];
    
    // Calculer le score pour chaque p√©riode bas√© sur le vent
    periods.forEach(period => {
        // Filtrer les heures de la p√©riode
        const periodHours = hourlyData.filter(w => {
            const hour = parseInt(w.time);
            return hour >= period.start && hour <= period.end;
        });
        
        // Calculer le score en fonction du vent moyen sur la p√©riode
        let periodScore = day.score; // score de base
        
        if (periodHours.length > 0) {
            // Calculer la vitesse moyenne du vent sur la p√©riode
            const avgWind = periodHours.reduce((sum, w) => sum + w.speed_kmh, 0) / periodHours.length;
            
            // Ajuster le score en fonction du vent
            // Vent faible (<15 km/h) = bon pour la p√™che
            // Vent fort (>25 km/h) = mauvais pour la p√™che
            if (avgWind < 15) {
                periodScore = Math.min(95, day.score + 20);
            } else if (avgWind < 20) {
                periodScore = Math.min(90, day.score + 10);
            } else if (avgWind < 25) {
                periodScore = day.score; // neutre
            } else if (avgWind < 30) {
                periodScore = Math.max(20, day.score - 15);
            } else {
                periodScore = Math.max(10, day.score - 30);
            }
            
            // Bonus pour le matin et le soir (meilleurs moments biologiques)
            if (period.name === 'Matin' || period.name === 'Soir') {
                periodScore = Math.min(95, periodScore + 5);
            }
            
            // P√©nalit√© pour la mi-journ√©e (soleil fort)
            if (period.name === 'Mi-journ√©e') {
                periodScore = Math.max(10, periodScore - 10);
            }
        }
        
        // D√©terminer la couleur
        let color = periodScore >= 80 ? '#10b981' : 
                   periodScore >= 60 ? '#3b82f6' : 
                   periodScore >= 40 ? '#f59e0b' : '#ef4444';
        
        hoursHtml += `<div class="hour-card" style="border-top-color:${color}">
            <div style="font-weight:600;color:#e2e8f0">${period.emoji} ${period.name}</div>
            <div style="font-size:1.3rem;font-weight:700;color:${color}">${Math.round(periodScore)}%</div>
            <div style="font-size:0.7rem;color:#94a3b8">${period.start}h-${period.end}h</div>
        </div>`;
    });
    
    // Ajouter une note sur la coh√©rence si n√©cessaire
    const avgPeriodScore = Math.round(
        (periods.reduce((sum, p, i) => {
            const score = parseInt(hoursHtml.match(new RegExp(`${p.emoji}.*?(\\d+)%`))?.[1] || day.score);
            return sum + score;
        }, 0)) / periods.length
    );
    
    if (Math.abs(avgPeriodScore - day.score) > 20) {
        console.log(`‚ÑπÔ∏è Jour ${day.date}: global=${day.score}, moyenne p√©riodes=${avgPeriodScore} (bas√© sur vent)`);
    }
    
} else {
    // Au-del√† de J+3, message de pr√©cision limit√©e
    hoursHtml = '<div style="grid-column:1/-1;text-align:center;padding:1rem;color:#94a3b8">Pr√©cision horaire insuffisante pour ce jour</div>';
}
document.getElementById('hourly-forecast-grid').innerHTML = hoursHtml;
        
        // === SECTION VENT D√âTAILL√â CORRIG√âE ===
        const windGrid = document.getElementById('hourlyWindGrid');
        if (day.hourlyWind && day.hourlyWind.length) {
            let windHtml = '';
            day.hourlyWind.forEach(item => {
                // Utiliser la direction en degr√©s pour calculer l'ic√¥ne
                const directionDeg = item.direction_deg || 0;
                const icon = getWindDirectionIcon(directionDeg);
                const speedCat = getWindSpeedCategory(item.speed_kmh);
                
                windHtml += `<div class="wind-card" data-wind-speed="${speedCat}">
                    <div class="hour">${item.time}</div>
                    <div class="speed">${item.speed_kmh} km/h</div>
                    <div class="direction-icon">${icon}</div>
                    <div class="direction-name" title="${item.direction_name}">${item.direction_abbr}</div>
                </div>`;
            });
            windGrid.innerHTML = windHtml;
            windGrid.style.display = 'flex';
        } else {
            windGrid.style.display = 'none';
        }
        
        document.getElementById('day-details').style.display = 'block';
        document.querySelectorAll('.forecast-day-card').forEach((card, i) => { 
            card.classList.toggle('active', i === index); 
        });
        document.querySelectorAll('.moon-day').forEach((el, i) => { 
            el.classList.toggle('active-moon', i === index); 
        });
    }
};

// ============================================
// GRAPHIQUE DE TENDANCE
// ============================================

const TrendChart = {
    update() {
        if (!AppState.forecastData) return;
        const ctx = document.getElementById('trend-chart');
        if (!ctx) return;
        if (AppState.trendChart) AppState.trendChart.destroy();
        
        const labels = AppState.forecastData.map(day => { 
            const d = new Date(day.date); 
            return d.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric' }); 
        });
        
        AppState.trendChart = new Chart(ctx, {
            type: 'line',
            data: { 
                labels: labels, 
                datasets: [{ 
                    label: 'Score', 
                    data: AppState.forecastData.map(day => day.score), 
                    borderColor: '#3b82f6', 
                    backgroundColor: 'rgba(59,130,246,0.1)', 
                    borderWidth: 2, 
                    fill: true, 
                    tension: 0.4, 
                    pointRadius: 3 
                }] 
            },
            options: { 
                responsive: true, 
                maintainAspectRatio: false, 
                plugins: { legend: { display: false } }, 
                scales: { 
                    x: { 
                        grid: { color: 'rgba(255,255,255,0.1)' }, 
                        ticks: { color: '#94a3b8' } 
                    }, 
                    y: { 
                        beginAtZero: true, 
                        max: 100, 
                        grid: { color: 'rgba(255,255,255,0.1)' }, 
                        ticks: { color: '#94a3b8', stepSize: 20 } 
                    } 
                } 
            }
        });
    }
};

// ============================================
// GESTION DES ALERTES
// ============================================

const Alerts = {
    update() {
        if (!AppState.forecastData) return;
        
        const bestDay = AppState.forecastData.reduce((best, day) => day.score > best.score ? day : best);
        const date = new Date(bestDay.date);
        const alertEl = document.getElementById('best-day-alert');
        const textEl = document.getElementById('best-day-text');
        
        if (alertEl && textEl) {
            alertEl.style.display = 'flex';
            textEl.textContent = `Meilleur jour: ${date.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric' })} (${bestDay.score}%)`;
        }
        
        const alertsList = document.getElementById('alerts-list');
        const oldWindAlert = document.getElementById('wind-alert');
        if (oldWindAlert) oldWindAlert.remove();
        
        const nextThree = AppState.forecastData.slice(0, 3);
        const threshold = Config.windThresholds[AppState.currentSpecies] || Config.windThresholds.default;
        const strongWindDays = nextThree.filter(day => day.wind.speed > threshold);
        
        if (strongWindDays.length > 0) {
            const windAlert = document.createElement('div');
            windAlert.id = 'wind-alert';
            windAlert.className = 'alert-banner';
            windAlert.style.background = 'linear-gradient(90deg,#f59e0b,#d97706)';
            windAlert.style.color = 'white';
            windAlert.style.padding = '0.75rem';
            windAlert.style.borderRadius = '8px';
            windAlert.style.marginBottom = '0.75rem';
            
            let message = `<i class="fas fa-wind"></i> ‚ö†Ô∏è Vent fort (>${threshold}km/h) dans les 3 jours : `;
            message += strongWindDays.map(day => {
                const d = new Date(day.date);
                return d.toLocaleDateString('fr-FR', { weekday: 'short', day: 'numeric' }) + ' ' + day.wind.speed + 'km/h';
            }).join(', ');
            
            windAlert.innerHTML = message;
            alertsList.prepend(windAlert);
        }
    }
};

// ============================================
// TABLEAU DES PR√âVISIONS HORAIRES
// ============================================

const HourlyTable = {
    show() {
        if (!AppState.forecastData || !AppState.currentSpot) return;
        const modal = document.getElementById('hourlyTableModal');
        const title = document.getElementById('hourly-table-title');
        const container = document.getElementById('hourly-table-container');
        
        title.innerHTML = `<i class="fas fa-table"></i> ${AppState.currentSpot.name} ‚Äì Fiabilit√© des pr√©visions`;
        
        let html = '<div style="overflow-x:auto;"><table style="width:100%;border-collapse:collapse;font-size:0.85rem"><thead><tr>';
        html += '<th style="background:#334155;color:#e2e8f0;padding:0.75rem;position:sticky;left:0">Heure</th>';
        
        // Limiter √† 3 jours pour la pr√©cision horaire
        const daysToShow = Math.min(3, AppState.forecastData.length);
        AppState.forecastData.slice(0, daysToShow).forEach((day, idx) => { 
            const d = new Date(day.date); 
            const conf = day.confidence || (idx === 0 ? 0.95 : idx === 1 ? 0.9 : 0.85);
            html += `<th style="background:#1e293b;color:#e2e8f0;padding:0.75rem">
                ${d.toLocaleDateString('fr-FR', { weekday:'short', day:'numeric' })}<br>
                <span style="font-size:0.7rem;color:#94a3b8">Fiabilit√© ${Math.round(conf*100)}%</span>
            </th>`; 
        });
        
        html += '</tr></thead><tbody>';
        
        for (let hour = 0; hour < 24; hour++) {
            html += '<tr>';
            html += `<td style="background:#334155;color:#e2e8f0;padding:0.5rem;position:sticky;left:0">${hour}h</td>`;
            
            AppState.forecastData.slice(0, daysToShow).forEach((day, dayIndex) => {
                let score = 50;
                const isDaytime = hour >= 6 && hour <= 19;
                const isMorning = hour >= 5 && hour <= 9;
                const isEvening = hour >= 16 && hour <= 19;
                
                if (isMorning || isEvening) {
                    score = Math.min(95, day.score + 10);
                } else if (isDaytime) {
                    score = Math.max(30, day.score - 10);
                } else {
                    score = Math.max(20, day.score - 20);
                }
                
                const confidence = day.confidence || (dayIndex === 0 ? 0.95 : dayIndex === 1 ? 0.9 : 0.85);
                score = Math.round(score * confidence + 50 * (1 - confidence));
                score = Math.max(20, Math.min(95, score));
                
                let scoreClass = 'score-very-poor';
                if (score >= 80) scoreClass = 'score-excellent';
                else if (score >= 60) scoreClass = 'score-good';
                else if (score >= 40) scoreClass = 'score-medium';
                
                html += `<td style="padding:0.5rem;text-align:center;border:1px solid #475569">
                    <div class="hour-score-cell ${scoreClass}" style="padding:0.4rem;color:white;border-radius:4px">${score}%</div>
                </td>`;
            });
            html += '</tr>';
        }
        
        html += '</tbody></table></div>';
        if (AppState.forecastData.length > 3) {
            html += '<p style="color:#94a3b8;margin-top:1rem;font-size:0.9rem"><i class="fas fa-info-circle"></i> Les pr√©visions horaires au-del√† de J+3 sont moins fiables ; seuls les scores journaliers sont affich√©s.</p>';
        }
        container.innerHTML = html;
        modal.style.display = 'flex';
        
        document.getElementById('closeHourlyTable').onclick = () => { 
            modal.style.display = 'none'; 
        };
        
        modal.onclick = (e) => { 
            if (e.target === modal) modal.style.display = 'none'; 
        };
    }
};

// ============================================
// S√âLECTION DES ESP√àCES
// ============================================

const SpeciesSelector = {
    init() {
        let html = '';
        Object.entries(Config.species).forEach(([key, s]) => {
            html += `<button class="btn btn-secondary species-btn ${key === 'loup' ? 'btn-primary' : ''}" onclick="window.selectSpecies('${key}', event)" style="margin-right:0.5rem;margin-bottom:0.5rem">${s.icon} ${s.name}</button>`;
        });
        document.getElementById('species-selector').innerHTML = html;
    },
    
    select(species, event) {
        AppState.currentSpecies = species;
        document.querySelectorAll('.species-btn').forEach(b => { 
            b.classList.remove('btn-primary'); 
            b.classList.add('btn-secondary'); 
        });
        if (event && event.target) { 
            event.target.classList.remove('btn-secondary'); 
            event.target.classList.add('btn-primary'); 
        }
        if (AppState.currentSpot) ForecastLoader.load();
    }
};

// ============================================
// RESTAURATION DU DERNIER SPOT
// ============================================

function restoreLastSpot() {
    const savedLat = localStorage.getItem('currentLat');
    const savedLon = localStorage.getItem('currentLon');
    const savedName = localStorage.getItem('currentSpotName');
    if (savedLat && savedLon) {
        AppState.currentLat = parseFloat(savedLat);
        AppState.currentLon = parseFloat(savedLon);
        const spot = { 
            lat: AppState.currentLat, 
            lon: AppState.currentLon, 
            name: savedName || 'Spot restaur√©', 
            type: 'custom', 
            depth: '?' 
        };
        AppState.currentSpot = spot;
        SpotSelector._updateUI(spot);
    }
}

// ============================================
// EXPOSITION DES FONCTIONS GLOBALES
// ============================================

window.calculateDistance = calculateDistance;
window.showNotification = showNotification;
window.toggleWindLayer = () => { WindAnimation.toggleLayer(); };
window.addWindAnimation = () => { WindAnimation.addAnimation(); };
window.removeWindAnimation = () => { WindAnimation.removeAnimation(); };
window.updateWindAnimation = (direction, speed) => { WindAnimation.updateAnimation(direction, speed); };
window.selectSpot = (param1, param2, param3) => { SpotSelector.select(param1, param2, param3); };
window.useCurrentLocation = () => { SpotSelector.useCurrentLocation(); };
window.loadForecast = () => { ForecastLoader.load(); };
window.selectDay = (index) => { ForecastDisplay.selectDay(index); };
window.showHourlyForecastTable = () => { HourlyTable.show(); };
window.selectSpecies = (species, event) => { SpeciesSelector.select(species, event); };

// ============================================
// INITIALISATION
// ============================================

document.addEventListener('DOMContentLoaded', () => {
    if (AppState.initialized) return;
    AppState.initialized = true;
    
    SpeciesSelector.init();
    restoreLastSpot();
    
    setTimeout(() => MapManager.init(), 100);
    
    if (!AppState.currentSpot && Config.spots && Config.spots.length > 0) {
        const defaultSpot = Config.spots[0];
        if (defaultSpot && defaultSpot.lat && defaultSpot.lon) {
            SpotSelector.select(defaultSpot.lat, defaultSpot.lon, defaultSpot.name);
        } else {
            SpotSelector.select(36.8065, 10.1815, 'Tunis Marina');
        }
    }
    
    // Test des fonctions de direction (√† supprimer en production)
    console.log("Test des ic√¥nes de vent :");
    [0, 45, 90, 135, 180, 225, 270, 315].forEach(deg => {
        console.log(`${deg}¬∞: ${getWindDirectionName(deg)} (${getWindDirectionAbbr(deg)}) ‚Üí ${getWindDirectionIcon(deg)}`);
    });
    
    window.AppDebug = AppState;
    console.log('‚úÖ Application initialis√©e (version scientifique corrig√©e)');
});
</script>
{% endblock %}